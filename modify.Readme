1. rtconfig.py
	6- CROSS_TOOL='keil'
	6+ CROSS_TOOL='gcc'
	//17- STM32_TYPE = 'STM32F10X_HD'
	//17+ STM32_TYPE = 'STM32L1XX_MD'
	28- EXEC_PATH 	= 'D:/SourceryGCC/bin'
	28+ EXEC_PATH 	= '/home/ptz/opt/sourcery/arm-none-eabi-gcc/arm-2012.09/bin'

2. rtconfig.h
	76- /* #define RT_USING_DFS */
	76+ #define RT_USING_DFS
	147- /* #define RT_USING_RTGUI */
	147+ #define RT_USING_RTGUI

	62- #define RT_USING_UART1
	62+ #define RT_USING_UART2

3. application.c
	147- extern void rtgui_system_server_init(void);
	147+ /*extern void rtgui_system_server_init(void);*/

4. board.h
	//22- #define STM32_USE_SDIO			1
	//22+ #define STM32_USE_SDIO			0
	38- #define STM32_SRAM_SIZE         64
	38+ #define STM32_SRAM_SIZE         48
	43- #define STM32_CONSOLE_USART		1
	43+ #define STM32_CONSOLE_USART		2

5. stm32_rom.ld
	9- CODE (rx) : ORIGIN = 0x08000000, LENGTH = 512k /* 512KB flash */
	9+ CODE (rx) : ORIGIN = 0x08000000, LENGTH = 256k /* 64KB flash */
	10- DATA (rw) : ORIGIN = 0x20000000, LENGTH =  64k /* 64K sram */
	10+ DATA (rw) : ORIGIN = 0x20000000, LENGTH =  48k /* 10K sram */

6. Library/CMSIS

7. Library/STM32L1xx_StdPeriph_Driver

8. Library/SConscript
	CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c
	STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c
	STM32F10x_StdPeriph_Driver/src/misc.c

	CMSIS/Device/ST/STM32L1xx/Source/Templates/system_stm32l1xx.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_adc.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_aes.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_aes_util.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_comp.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_crc.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_dac.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_dbgmcu.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_dma.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_exti.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_flash.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_flash_ramfunc.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_fsmc.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_gpio.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_i2c.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_iwdg.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_lcd.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_opamp.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_pwr.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_rcc.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_rtc.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_sdio.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_spi.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_syscfg.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_tim.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_usart.c
	STM32L1xx_StdPeriph_Driver/src/stm32l1xx_wwdg.c
	STM32L1xx_StdPeriph_Driver/src/misc.c

	startup_scripts['STM32F10X_CL']     = 'startup_stm32f10x_cl.s'
	startup_scripts['STM32F10X_HD']     = 'startup_stm32f10x_hd.s'
	startup_scripts['STM32F10X_HD_VL']  = 'startup_stm32f10x_hd_vl.s'
	startup_scripts['STM32F10X_LD']     = 'startup_stm32f10x_ld.s'
	startup_scripts['STM32F10X_LD_VL']  = 'startup_stm32f10x_ld_vl.s'
	startup_scripts['STM32F10X_MD']     = 'startup_stm32f10x_md.s'
	startup_scripts['STM32F10X_MD_VL']  = 'startup_stm32f10x_md_vl.s'
	startup_scripts['STM32F10X_XL']	    = 'startup_stm32f10x_xl.s'

	startup_scripts['STM32L1XX_MD']     = 'startup_stm32l1xx_md.s'
	startup_scripts['STM32L1XX_MDP']     = 'startup_stm32l1xx_mdp.s'
	startup_scripts['STM32L1XX_HD']     = 'startup_stm32l1xx_hd.s'

	if rtconfig.CROSS_TOOL == 'gcc':
		src = src + ['CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/gcc_ride7/' + startup_scripts[rtconfig.STM32_TYPE]]
	elif rtconfig.CROSS_TOOL == 'keil':
		src = src + ['CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/' + startup_scripts[rtconfig.STM32_TYPE]]
	elif rtconfig.CROSS_TOOL == 'iar':
		src = src + ['CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/iar/' + startup_scripts[rtconfig.STM32_TYPE]]

	if rtconfig.CROSS_TOOL == 'gcc':
		src = src + ['CMSIS/Device/ST/STM32L1xx/Source/Templates/gcc_ride7/' + startup_scripts[rtconfig.STM32_TYPE]]
	elif rtconfig.CROSS_TOOL == 'keil':
		src = src + ['CMSIS/Device/ST/STM32L1xx/Source/Templates/arm/' + startup_scripts[rtconfig.STM32_TYPE]]
	elif rtconfig.CROSS_TOOL == 'iar':
		src = src + ['CMSIS/Device/ST/STM32L1xx/Source/Templates/iar/' + startup_scripts[rtconfig.STM32_TYPE]]

	path = [cwd + '/STM32F10x_StdPeriph_Driver/inc', 
		cwd + '/CMSIS/CM3/DeviceSupport/ST/STM32F10x']

	path = [cwd + '/STM32L1xx_StdPeriph_Driver/inc', 
		cwd + '/CMSIS/Device/ST/STM32L1xx/Include']

    path += [cwd + '/CMSIS/CM3/CoreSupport']
    src += [cwd + '/CMSIS/CM3/CoreSupport/core_cm3.c']

    path += [cwd + '/CMSIS/Include']

9. board.c
	#include "stm32f10x.h"
	#include "stm32f10x_fsmc.h"

	#include "stm32l1xx.h"
	#include "stm32l1xx_fsmc.h"

10. stm32l1xx_it.c
	#include <board.h>
	#include <rtthread.h>

	void PendSV_Handler(void)
	{
	}

	void HardFault_Handler(void)
	{
	  /* Go to infinite loop when Hard Fault exception occurs */
	  while (1)
	  {
	  }
	}

	void SysTick_Handler(void)
	{
		extern void rt_hw_timer_handler(void);
		rt_hw_timer_handler();
	}

	/*******************************************************************************
	* Function Name  : DMA1_Channel2_IRQHandler
	* Description    : This function handles DMA1 Channel 2 interrupt request.
	* Input          : None
	* Output         : None
	* Return         : None
	*******************************************************************************/
	void DMA1_Channel2_IRQHandler(void)
	{
	#ifdef RT_USING_UART3
		extern struct rt_device uart3_device;
		extern void rt_hw_serial_dma_tx_isr(struct rt_device *device);

		/* enter interrupt */
		rt_interrupt_enter();

		if (DMA_GetITStatus(DMA1_IT_TC2))
		{
			/* transmission complete, invoke serial dma tx isr */
			rt_hw_serial_dma_tx_isr(&uart3_device);
		}

		/* clear DMA flag */
		DMA_ClearFlag(DMA1_FLAG_TC2 | DMA1_FLAG_TE2);

		/* leave interrupt */
		rt_interrupt_leave();
	#endif
	}

	/*******************************************************************************
	* Function Name  : USART1_IRQHandler
	* Description    : This function handles USART1 global interrupt request.
	* Input          : None
	* Output         : None
	* Return         : None
	*******************************************************************************/
	void USART1_IRQHandler(void)
	{
	#ifdef RT_USING_UART1
		extern struct rt_device uart1_device;
		extern void rt_hw_serial_isr(struct rt_device *device);

		/* enter interrupt */
		rt_interrupt_enter();

		rt_hw_serial_isr(&uart1_device);

		/* leave interrupt */
		rt_interrupt_leave();
	#endif
	}

	/*******************************************************************************
	* Function Name  : USART2_IRQHandler
	* Description    : This function handles USART2 global interrupt request.
	* Input          : None
	* Output         : None
	* Return         : None
	*******************************************************************************/
	void USART2_IRQHandler(void)
	{
	#ifdef RT_USING_UART2
		extern struct rt_device uart2_device;
		extern void rt_hw_serial_isr(struct rt_device *device);

		/* enter interrupt */
		rt_interrupt_enter();

		rt_hw_serial_isr(&uart2_device);

		/* leave interrupt */
		rt_interrupt_leave();
	#endif
	}

	/*******************************************************************************
	* Function Name  : USART3_IRQHandler
	* Description    : This function handles USART3 global interrupt request.
	* Input          : None
	* Output         : None
	* Return         : None
	*******************************************************************************/
	void USART3_IRQHandler(void)
	{
	#ifdef RT_USING_UART3
		extern struct rt_device uart3_device;
		extern void rt_hw_serial_isr(struct rt_device *device);

		/* enter interrupt */
		rt_interrupt_enter();

		rt_hw_serial_isr(&uart3_device);

		/* leave interrupt */
		rt_interrupt_leave();
	#endif
	}

	#if defined(RT_USING_DFS) && STM32_USE_SDIO
	/*******************************************************************************
	* Function Name  : SDIO_IRQHandler
	* Description    : This function handles SDIO global interrupt request.
	* Input          : None
	* Output         : None
	* Return         : None
	*******************************************************************************/
	void SDIO_IRQHandler(void)
	{
		extern int SD_ProcessIRQSrc(void);

		/* enter interrupt */
		rt_interrupt_enter();

		/* Process All SDIO Interrupt Sources */
		SD_ProcessIRQSrc();

		/* leave interrupt */
		rt_interrupt_leave();
	}
	#endif

	#ifdef RT_USING_LWIP
	#ifdef STM32F10X_CL
	/*******************************************************************************
	* Function Name  : ETH_IRQHandler
	* Description    : This function handles ETH interrupt request.
	* Input          : None
	* Output         : None
	* Return         : None
	*******************************************************************************/
	void ETH_IRQHandler(void)
	{
		extern void rt_hw_stm32_eth_isr(void);

		/* enter interrupt */
		rt_interrupt_enter();

		rt_hw_stm32_eth_isr();

		/* leave interrupt */
		rt_interrupt_leave();
	}
	#else
	#if (STM32_ETH_IF == 0)
	/*******************************************************************************
	* Function Name  : EXTI0_IRQHandler
	* Description    : This function handles External interrupt Line 0 request.
	* Input          : None
	* Output         : None
	* Return         : None
	*******************************************************************************/
	void EXTI2_IRQHandler(void)
	{
		extern void enc28j60_isr(void);

		/* enter interrupt */
		rt_interrupt_enter();

		enc28j60_isr();

		/* Clear the Key Button EXTI line pending bit */
		EXTI_ClearITPendingBit(EXTI_Line2);

		/* leave interrupt */
		rt_interrupt_leave();
	}
	#endif

	#if (STM32_ETH_IF == 1)
	/*******************************************************************************
	* Function Name  : EXTI4_IRQHandler
	* Description    : This function handles External lines 9 to 5 interrupt request.
	* Input          : None
	* Output         : None
	* Return         : None
	*******************************************************************************/
	void EXTI4_IRQHandler(void)
	{
		extern void rt_dm9000_isr(void);

		/* enter interrupt */
		rt_interrupt_enter();

		/* Clear the DM9000A EXTI line pending bit */
		EXTI_ClearITPendingBit(EXTI_Line4);

		rt_dm9000_isr();

		/* leave interrupt */
		rt_interrupt_leave();
	}
	#endif
	#endif
	#endif /* end of RT_USING_LWIP */

	/**
	  * @}
	  */

11. led.c
	#include <stm32f10x.h>
	#include <stm32l1xx.h>

	#define led1_rcc                    RCC_APB2Periph_GPIOE
	#define led1_rcc                    RCC_AHBPeriph_GPIOE

	#define led2_rcc                    RCC_APB2Periph_GPIOE
	#define led2_rcc                    RCC_AHBPeriph_GPIOE

    RCC_APB2PeriphClockCmd(led1_rcc|led2_rcc,ENABLE);
    RCC_AHBPeriphClockCmd(led1_rcc|led2_rcc,ENABLE);

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

12. msd.h
	#include <stm32f10x.h>
	#include <stm32l1xx.h>

	typedef __IO uint8_t vu8;
	typedef __IO uint16_t vu16;
	typedef __IO uint32_t vu32;
	typedef uint8_t u8;
	typedef uint16_t u16;
	typedef uint32_t u32;

13. msd.c
	#include <stm32f10x_spi.h>
	#include <stm32l1xx_spi.h>

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOD, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA | RCC_AHBPeriph_GPIOD, ENABLE);

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

14. rtc.c
	#include <stm32f10x.h>
	#include <stm32l1xx.h>

    *time = RTC_GetCounter();
    *time = RTC_GetWakeUpCounter();

    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);

    PWR_BackupAccessCmd(ENABLE);
    PWR_RTCAccessCmd(ENABLE);

    RTC_WaitForLastTask();
    RTC_WaitForSynchro();

    RTC_SetCounter(*time);
    RTC_SetWakeUpCounter(*time);

    BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);
	RTC_WriteBackupRegister(RTC_BKP_DR0, 0x32F2);

    u32 count=0x200000;
    uint32_t count=0x200000;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);

    BKP_DeInit();
    RTC_DeInit();

	if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)
    if (RTC_ReadBackupRegister(RTC_BKP_DR0) != 0x32F2)

    ti = localtime(&now);
    ti = (struct tm *)localtime(&now);

    RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */

15. serial.h
	#include <stm32f10x.h>
	#include <stm32l1xx.h>

16. serial.c
	#include <stm32f10x_dma.h>
	#include <stm32l1xx_dma.h>

	#include <stm32f10x_usart.h>
	#include <stm32l1xx_usart.h>

17. ssd1289.c
	#include "stm32f10x.h"
	#include "stm32l1xx.h"

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_GPIOF
                               | RCC_APB2Periph_GPIOG, ENABLE);

    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOD | RCC_AHBPeriph_GPIOE 
			| RCC_AHBPeriph_GPIOF | RCC_AHBPeriph_GPIOG, ENABLE);

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

18. startup.c
	#include "stm32f10x.h"
	#include "stm32l1xx.h"

	void assert_failed(u8 *file, u32 line)
	void assert_failed(uint8_t *file, uint32_t line)

19. SConscript
	src_bsp = ['application.c', 'startup.c', 'board.c', 'stm32f10x_it.c']
	src_bsp = ['application.c', 'startup.c', 'board.c', 'stm32l1xx_it.c']

	if rtconfig.STM32_TYPE == 'STM32F10X_HD':
	if rtconfig.STM32_TYPE == 'STM32L1XX_HD':

20. touch.c
	#include "stm32f10x.h"
	#include "stm32l1xx.h"

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB,ENABLE);

    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;

    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource1);


	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC,ENABLE);

	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;


    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA
                           | RCC_APB2Periph_AFIO | RCC_APB2Periph_SPI1,
                           ENABLE);

    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);

    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;

    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

21. usart.c
	#include <stm32f10x_dma.h>
	#include <stm32l1xx_dma.h>

	#if defined(STM32F10X_LD) || defined(STM32F10X_MD) || defined(STM32F10X_CL)
	#define UART2_GPIO_TX	    GPIO_Pin_5
	#define UART2_GPIO_RX	    GPIO_Pin_6
	#define UART2_GPIO	    	GPIOD
	#define RCC_APBPeriph_UART2	RCC_APB1Periph_USART2
	#else /* for STM32F10X_HD */
	/* USART2_REMAP = 0 */

	#define UART2_TX_DMA		DMA1_Channel7
	#define UART2_RX_DMA		DMA1_Channel6
	#endif

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	#if (defined(STM32F10X_LD) || defined(STM32F10X_MD) || defined(STM32F10X_CL))
		/* Enable AFIO and GPIOD clock */
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOD, ENABLE);
		/* Enable the USART2 Pins Software Remapping */
		GPIO_PinRemapConfig(GPIO_Remap_USART2, ENABLE);
	#else
		/* Enable AFIO and GPIOA clock */
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA, ENABLE);
	#endif
		/* Enable USART2 clock */
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

